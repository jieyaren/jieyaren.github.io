---
layout: post
title: 算法4/手撕算法整理笔记
category: [algorithm]
tags: [data structure, algorithm]
---
{% include JB/setup %}

---

> https://github.com/labuladong/fucking-algorithm

---

## 基础

- 完整详细的定义问题，找出解决问题所必须的基本抽象操作并定义一份API
- 间接地实现一种础计算法，给出一个开发用例并使用实际数据作为输入
- 当实现所能解决的问题的最大规模达不到期望时决定改进还是放弃
- 逐步改进，通过经验性分析和数学分析验证改进后的结果
- 用更高层侧的抽象表示数据接口活算法来设计更高级的改进版本
- 如果可能尽量为最坏情况下的性能提供保证，在处理普通数据时也要有良好的性能
- 在适当的时候讲更细致的深入援救留给有经验的研究之并继续解决下一个问题

---

## 排序

**初级排序**

- 选择排序 
  - 运行时间和输入无关，并不能保留信息，有记忆信息更高效
- 插入排序
  - 如果有序，更友好
  - 进阶，希尔排序，分组插入排序
    - 分组怎么确定？

**归并排序**

- 难在原地归并
- 递归归并

**快速排序**

- 如何选位置？
- 改进方案
  - 小数组用插入排序
  - 三取样切分，中位数的选取

**优先队列**

二叉堆维护

- 插入
  - 加到数组末尾，上浮
- 删除最大元素
  - 最后一个元素放到顶端，下沉

多叉堆

堆排序

---

## 查找

基本抽象 符号表（dict） put/get/delete/contains

- 是否需要有序 min/max/range-find
- 插入和查找能不能都快
  - 插入块不考虑查找，链表，插入慢查找快，哈希表？
  - 二叉查找树，插入对数查找对数（二分）

**二叉查找树**

左边小右边大

删除节点

- 右边大，但是右边的左节点小，要找到右边没有左子节点的左节点，作为被删节点的交换节点
- 左边一定是小于右边的，所以要确定右边最小的，抬到被删节点的位置就行了
- 如果删除的是最小节点，那一定是左边的没有左子节点的节点，右子节点直接抬上来就行了，因为左边没了

最坏情况，数不平衡，退化成链表

范围查找 也就是中序遍历

**平衡查找树**

在插入场景下保证二叉查找树的完美平衡难度过大

- 2-3查找树，插入能尽可能的保持平衡 

  - 如果插入终点是2节点，就转换成3节点
  - 如果终点是3节点
    - 只有一个3节点，该节点编程4节点，4节点可以轻松抽出二叉树子树
      - 父2节点，子3节点，同理，抽出子树，把子树父节点塞到父节点
      - 父3节点，子3节点，同理，抽出子树，把子树父节点塞到父节点，父节点再抽出子树，重复
      - 全是3节点 树高 +1

- 红黑二叉查找树描述2-3树？？

  - 替换3节点 抽出子树 左连接子树要标红 有图
  - 红连接放平，就是2-3树了

  一种等价定义

  - 红连接均为左连接
  - 没有任何一个节点同时和两条红连接相连
  - 完美黑色平衡，任意空连接到根节点的路径上的黑连接相同



---

## 动态规划

- 求最值的，通常要穷举，聪明的穷举(dp table)
- 重叠子问题以及最优子结构
  - 如果没有最优子结构，改造转换
- 正确的状态转移方程
  - 数学归纳
  - dp[i]代表了什么？
    - 最长上升子序列问题，**dp[i] 表示以 nums[i] 这个数结尾的最长递增子序列的长度**
  - 公式条件？
  - dp的遍历方向问题
    - **遍历的过程中，所需的状态必须是已经计算出来的**。
    - **遍历的终点必须是存储结果的那个位置**。

 



---

Any advice mailto:wanghenshui@qq.com, thanks! 

Pulling a [issue](https://github.com/wanghenshui/wanghenshui.github.io/issues/new) is fine! I can get noticed from email.

看到这里或许你有建议或者疑问或者指出我的错误，我的邮箱wanghenshui@qq.com 先谢指教。或者到博客上提[issue](https://github.com/wanghenshui/wanghenshui.github.io/issues/new) 我能收到邮件提醒。